<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
  </head>
  <body>
    

	  
<label id="directions" style="display:block">Enter OpenAI key to transcribe the audio files to text. All audio files in the repository will be transcribed.</label>
	  
<br>

<!-- ----------------------------------- -->
<!-- Strings that need to be stored in a secret location for security: temporarily as inputs to test app functionality -->
<input id="auth_id" type="text" value="" placeholder="auth_id" rows="10" cols="100" style="display:block; text-align: left; width: 150px;">
	  
<input id="OPENAI_API_KEY" type="text" value="" placeholder="OPENAI_API_KEY" rows="10" cols="100" style="display:block; text-align: left; width: 150px;">
<!-- ----------------------------------- -->
	
<br><br>

<button id="readaudio" onclick="readaudio()">Transcribe audios</button>


	  
<!-- View results -->
<div id="output" style="font-family:courier;font-size:24px;height:300px"></div>


<!-- View results -->
<div align="left">
    <table style='text-align: center; width: 600px; display:block'>
      <tr>
        <td>
		<label id="journal_label" style="display:block">Journal text</label>
      		<br>
      		<textarea id="journal" rows="35" cols="100" placeholder="Journal text" style="display:block"></textarea>
	</td>
        <td>
		<label id="chatbot_label" style="display:block">Chatbot area</label>
      		<br>
      		<textarea id="chatbot" rows="35" cols="100" placeholder="Chatbot text" style="display:block"></textarea>
	</td>
      </tr>
    </table>
</div>  
    



	  
<!-- --------------------------------------------------- -->

<!-- CSS -->
<style>
div {position: relative; z-index: 2;},
  table {border-collapse: collapse; position: absolute;}
  td,
  th {border: 1px solid black;padding: 10px 20px;}
audio {position: absolute; top: 175px;}
</style>

	  
<!-- --------------------------------------------------- -->
	  


	  
<script>

const outp = document.getElementById('output');

const journal_filename = "text_data.txt";
const repoOwner = 'CodeSolutions2';
const repoName = 'audio_2_text_webapp';

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#controls
var audioElement = document.createElement('audio');
audioElement.setAttribute("controls", true);
audioElement.setAttribute("type", "audio/mpeg");

const OPENAI_API_KEY = document.getElementById("OPENAI_API_KEY").value;

// Input the secrets here: I do not know how to do this yet
const auth = document.getElementById("auth_id").value;
	
// ----------------------------------------------------

// Train model on existing journal


// ----------------------------------------------------

// Read in new audio (transcribe) --> add new text to existing journal 
async function input_new_audio_into_journal() {

	return await readaudio()
		.then(async function(string_out) { 
		console.log("string_out: ", string_out);
			
		// New data to add to the journal is string_out
		var out = await PUT_add_to_a_file_wo_auth_GitHub_RESTAPI(journal_filename, string_out);
		console.log("out:", out);
		return out;
	})
	
}

// ----------------------------------------------------
	
async function readaudio() {
	
	return await get_audio_file_objects()
	.then(file_objects => { 
		console.log("file_objects:", file_objects);
		// var dict_out = [];
		file_objects.forEach(async function(file_object, index) {
			
			console.log("file_object:", file_object);
			
			filename = file_object.name;
			console.log("filename:", filename);
			
			let out0 = filename.split('_');

			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
			let YYYY = out0.slice(0,1).toString();
			let MM = out0.slice(1,2).toString();
			let DD = out0.slice(2,3).toString();
			let HH = out0.slice(3,4).toString();
			let mm = out0.slice(4,5).toString();
			let ss = out0.slice(5,6).toString();

			const regex = /(,)+/g;
			
			YYYY = YYYY.replace(regex, '');
			MM = MM.replace(regex, '');
			DD = DD.replace(regex, '');
			HH = HH.replace(regex, '');
			mm = mm.replace(regex, '');
			ss = ss.replace(regex, '');
			console.log("YYYY:", YYYY);
			console.log("MM:", MM);
			console.log("DD:", DD);
			console.log("HH:", HH);
			console.log("mm:", mm);
			console.log("ss:", ss);

			// -----------------------------------

			let file_download_url = file_object.download_url;
			console.log("file_download_url:", file_download_url);
			
			// -----------------------------------

			// REST API to convert .mp3 to text
			
			// ------------------------------------------
			// Form submission
			// ------------------------------------------
			// Way 2: read in the mp3 as file_download_url --> convert to  blob_object
			var text_out = await fetch(file_download_url)
  				.then(response => response.blob())
			 	.then(async function(blob_object) { 
			 		console.log("blob_object: ", blob_object);
					var text_out = await openai_transcription(blob_object, 'blob_object');
					// var text_out = await openai_translation(blob_object, 'blob_object');
					// await openai_text_to_speech();
					return text_out;
				})
				.catch(error => { console.log(error); });
			
			// ------------------------------------------

			// Show audio element on HTML
			audioElement.src = file_download_url;
			document.body.appendChild(audioElement);
			console.log("audioElement: ", audioElement);

			// ------------------------------------------
			
			// Create a dictionary w/ date, time, and text
			// dict_out.push({date: [YYYY, MM, DD], time: [HH, mm, ss], text: text_out});
			string_out =+ `${YYYY}_${MM}_${DD}_${HH}_${mm}_${ss}\\n${text_out}\\n`;

			// Processing information
			outp.innerHTML = 'Processing audio';
		  });

		   outp.innerHTML = 'Processing Done'; console.log("string_out:", string_out); return string_out; 
	});
}

	
// ----------------------------------------------------


async function openai_transcription(file_input, which_input) {

	const url = 'https://api.openai.com/v1/audio/transcriptions';

	const headers = new Headers();
	// headers.append("Content-Type", "multipart/form-data");
	headers.append("Authorization", 'Bearer ' + OPENAI_API_KEY);
	headers.append("Accept", "application/json");
	
	const formData = new FormData();
	if (which_input == 'blob_object') {
		formData.append("file", file_input);
	} else {
		// using a file_blob_object
		formData.append("file", file_input, "recording.mp3"); // mp3, mp4, mpeg, mpga, m4a, wav, or webm
	}
	formData.append("model", "whisper-1");
	formData.append("prompt", "Transcribe the audio");  // Style context for the transcription
	formData.append("response_format", "text");  // json, text, srt, verbose_json, or vtt
	formData.append("temperature", "0");  // The sampling temperature, between 0 (accurate) and 1 (random response)
	formData.append("language", "en");
	formData.append("transcription", "plain text"); // plain text, srt, vtt
	
	const options = {method: 'POST', 
		       headers: headers, 
		       body: formData,
		       redirect: "follow"
		      };
	
	// Print text part of JSON response only with user message
	return await fetch(url, options)
		.then(response => response.text())
		.then(result => { console.log(result); return result; })
		.catch(error => { console.log(error); });
	
}
	

// ----------------------------------------------------

async function openai_translation(file_input) {
	
	const url = 'https://api.openai.com/v1/audio/translations';

	const headers = new Headers();
	// headers.append("Content-Type", "multipart/form-data");
	headers.append("Authorization", 'Bearer ' + OPENAI_API_KEY);
	headers.append("Accept", "application/json");
	
	const formData = new FormData();
	if (which_input == 'blob_object') {
		formData.append("file", file_input);
	} else {
		// using a file_blob_object
		formData.append("file", file_input, "recording.mp3"); // mp3, mp4, mpeg, mpga, m4a, wav, or webm
	}
	formData.append("model", "whisper-1");
	formData.append("prompt", "Transcribe the audio");  // Style context for the transcription
	formData.append("response_format", "text");  // json, text, srt, verbose_json, or vtt
	formData.append("temperature", "0");  // The sampling temperature, between 0 (accurate) and 1 (random response)
	formData.append("language", "en");
	formData.append("transcription", "plain text"); // plain text, srt, vtt
	
	const options = {method: 'POST', 
		       headers: headers, 
		       body: formData,
		       redirect: "follow"
		      };
	
	// Print text part of JSON response only with user message
	return await fetch(url, options)
		.then(response => response.text())
		.then(result => { console.log(result); return result; })
		.catch(error => { console.log(error); });
	
}

// ----------------------------------------------------

async function openai_text_to_speech() {
	
	const url = "https://api.openai.com/v1/audio/speech";
	
	var data = {"model": "tts-1-hd", 
		    "input": "OpenAI now also supports text to speech with two models: tts-1 and tts-1-hd. For real-time applications, the standard tts-1 model provides the lowest latency but at a lower quality than the tts-1-hd model. Due to the way the audio is generated, tts-1 is likely to generate content that has more static in certain situations than tts-1-hd. In some cases, the audio may not have noticeable differences depending on your listening device and the individual person. The input to generate the audio from can be up to 4096 characters. Supported voices are alloy, echo, fable, onyx, nova, and shimmer. Supported response formats are mp3, opus, aac, and flac. It is also possible to control the speed, select a value from 0.25 to 4.0. 1.0 is the default. There is no direct mechanism to control the emotional output of the audio generated. Certain factors may influence the output audio like capitalization or grammar but OpenAI's internal tests with these have yielded mixed results. Please note that OpenAI's Usage Policies require you to provide a clear disclosure to end users that the TTS voice they are hearing is AI-generated and not a human voice.",
    "voice": "alloy",
    "response_format": "mp3",
    "speed": "1.1"};
	
	var headers = {"Content-Type": "application/json", "Authorization": 'Bearer ' + OPENAI_API_KEY}
	var options = {method : 'post', headers: headers, body : JSON.stringify(data), redirect: "follow"};
  
	// Print text part of JSON response only with user message
	return await fetch(url, options)
            .then(res => res.json())
            .then(res => {
		    var json_response = JSON.parse(JSON.stringify(res));
		    console.log('response: ', json_response); 
		    return json_response;
            })
            .catch(error => { console.log(error); });
	
}
	
// ----------------------------------------------------

	
async function get_audio_file_objects() {
	
	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;

	var file_objects = [];
	await fetch(url).then(res => res.json()).then(data => {
		    data.forEach(file => {
		      if (file.type === 'file' && file.name.match(/.(mp3)$/i)) {
			file_objects.push(file);
		      }
		    });
		  }).catch(error => { outp.innerHTML += error; });
	
    	console.log('file_objects: ', file_objects);
	
	return file_objects;
}


// ----------------------------------------------------


async function PUT_add_to_a_file_wo_auth_GitHub_RESTAPI(journal_filename, new_string_content) {
	
   // PUT into an existing file
   var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${journal_filename}`;

   return await GET_text_from_file_wo_auth_GitHub_RESTAPI()
	   .then(async function (file_objects) {
		var file_object = file_objects.at(0);
		   
		var file_download_url = file_object.download_url;
		console.log("file_download_url:", file_download_url);
		   
		var sha_val = file_object.sha;
		console.log("sha_val:", sha_val);

		// Way 0: to get text from file
		let data_github_encoded_format = file_object.content;
		console.log("data_github_encoded_format:", data_github_encoded_format);

		return file_download_url;
	   })
	   .then(async function (file_download_url) {
		// Way 1: to get text from file
		var text_out = await fetch(file_download_url); return text_out
	   })
	   .then(response => response.text())
	   .then(async function(text_out) { 
		   console.log("text_out: ", text_out);
		   return text_out;
	   })
	   .catch(error => { console.log(error); });


// ----------------------------------------------------

	
async function PUT_add_to_a_file_w_auth_GitHub_RESTAPI(journal_filename, new_string_content) {
	
   // PUT into an existing file
   var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${journal_filename}`;

   return await GET_text_from_file_w_auth_GitHub_RESTAPI()
	   .then(async function (out) {
		   sha_val = out.sha;
		   let data_github_encoded_format = out.content;
		   
		   let data_decoded0 = atob(data_github_encoded_format);
		   console.log('data already in file decoded:', data_decoded0);
		   
		   // Add new content to file
		   raw_text = data_decoded0.concat(new_string_content);
		   console.log('raw_text:', raw_text); 
		   
		// Encode protected data into github's encoded format
		let content_encoded0 = btoa(raw_text);
		console.log("content_encoded0: ", content_encoded0);
		
		var data = {"message": message, "committer":{"name":"App name","email":"App email"}, "content": content_encoded0, "sha": sha_val};
		var headers = {"Accept": "application/vnd.github+json", "Authorization": `Bearer ${auth}`, "X-GitHub-Api-Version": "2022-11-28"};
		var options = {method : 'PUT', headers: headers, body : JSON.stringify(data)};
		var out1 = await fetch(url, options); return out1; })
	   		.then(res => { console.log(res); } )
	   		.catch(error => { console.log(error); });

}

	
// ----------------------------------------------------

	
async function GET_text_from_file_w_auth_GitHub_RESTAPI() {

	// GET data in a file - Way 0: REST API (WORKS!)
	// https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#get-repository-content
	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${journal_filename}`;

	var headers = {"Accept": "application/vnd.github+json", "Authorization": `Bearer ${auth}`, "X-GitHub-Api-Version": "2022-11-28"}
	var options = {method : 'GET', headers: headers};
	
	return await fetch(url, options)
		.then(res => res.json())
		.then(data => { return data; })
		.catch(error => { console.log(error); });
}

	
// ----------------------------------------------------

	
async function GET_text_from_file_wo_auth_GitHub_RESTAPI() {
	
	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;

	var file_objects = [];
	return await fetch(url)
		.then(res => res.json())
		.then(data => { data.forEach(async function(file) {
			    var regexp = new RegExp(`${journal_filename}`, 'g');
		      if (file.type === 'file' && file.name.match(regexp)) {
			 file_objects.push(file);
		      }
		    });
		    return file_objects;
		})
		.catch(error => { console.log(error); });
}


// ----------------------------------------------------



// ----------------------------------------------------
  
</script>

  </body>
</html>
